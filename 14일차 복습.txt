클래스
	- 하나의 정보를 표현하기 위해 여러 변수들과 기능들을 모아 놓은 것
	- 필드, 생성자, 메소드로 구성됨.
	-필드 : 공통되고 필수인 정보, 속성. 클래스에 속하는 속성값들.
	-필드는 일반적으로 접근제한자가 private이다. 외부에서 직접 접근을 막음. getter와 setter로 접근해서 값을 변경.
	-생성자 : 필드 초기화
	- 메소드 : 필요한 기능, 대부분 필드의 값을 변경하는 기능.
	-메소드는 일반적으로 접근제한자가 public이다.
	
	접근 제한자
	-private		: 클래스 내부에서만
	-(default)		: 클래스 내부+ 같은 패키지 내 클래스
	-protected	: 클래스 내부+ 같은 패키지 내 클래스 + 자식 클래스
	-public		: 클래스 내부+ 같은 패키지 내 클래스 + 자식 클래스 + 외부 클래스

	같은 이름의 클래스는 존재할 수 있다/없다?
		=>같은 패키지 내에서는 존재할 수 있다.
		=>다른 패키지에서는 존재할 수 있다.

	public 클래스 조건
	클래스 명과 파일 명이 같아야함. 즉 하나의 파일에 하나의 public클래스 

	-클래스 필드 (=static 필드) : 실행시 클래스 로더에 의해 클래스가 메모리에 올라오면 필드들이 할당.
	- 객체들이 클래스 필드를 공유
	-인스턴스 필드 : 객체가 생성될 때 필드들이 할당
	-객체마다 인스턴스 필드를 가지고 있음.

	필드 초기화 순서
	클래스 필드 : 
		1. 필드의 기본 값으로 초기화
		2. 명시적 초기화(선언과 동시에 초기화)
		3. 초기화 블록(static{}안에 있는)
	인스턴스 필드
		1. 필드의 기본 값으로 초기화
		2. 명시적 초기화(선언과 동시에 초기화)
		3. 초기화 블록( {}안에 있는)
		4. 생성자를 통한 초기화.

	클래스 필드/ 메소드: 
	-클래스 메소드에서 사용 가능? 가능
	-인스턴스 메소드에서 사용 가능? 가능

	인스턴스 필드/메소드 
	-클래스 메소드에서 사용 가능? 불가능(객체 생성이 필요하기 때문에)
		-> 직접 사용은 불가능 하지만 , 메소드 안에서 명시적으로 객체를 만들어주면 사용 가능. static 메소드에서 Scanner 객체 만들어서 Scanner 사용하듯.
	-인스턴스 메소드에서 사용 가능? 가능

상속
-부모 클래스의 필드, 메소드를 상속받아 자식 클래스가 활용하는 것.
-이때 접근 제한자의 유형에 관계 없이 상속 받기는 다 받음. 
-그러나 접근제한자가 private인 필드/메소드는 직접 접근해서 사용할 수 없다.

상속 하는 이유
-코드의 중복 제거(사실상 실패)
-다형성을 이용하여 메소드 중복을 제거

class 자식클래스명 extends 부모클래스명{

자바에서는 다중상속 허용 안됨.
다만 인터페이스에서는 다중상속 허용

다형성 : 하나의 객체가 여러가지 타입을 가질 수 있는 것

매개변수의 다형성

public void 전원(Tv tv){}
public void 전원(Aircon a){}
public void 전원(Computer b){}

->  매개변수로 여러 객체들이 올 수 있는데, 이때 오는 객체들을 동일한 조상 클래스로 캐스팅하여 경제적으로 호출함.

public void 전원(전자제품 obj){}


객체의 다형성
Tv tv1, tv2, tv3;
컴퓨터 com1, com2, com3;
에어컨 에어컨1;

-> 위의 상황에서는 다양한 클래스의 객체들을 하나로 관리할 수 없다.

클래스 형변환
자동
 -자식객체를 => 부모 데이터형 참조변수에 저장 


강제
- 부모객체를 => 자식 데이처형 참조변수에 저장(조건부로 가능)
쌩 부모객체를 자식 참조변수에 저장하면 자식 객체에서 구현된 메소드, 멤버에 접근할 수 없음.
그러니 이미 한번 업캐스팅 된 자식객체를 다시 본래의 클래스로 데이터 형변환 하는 경우에 가능.


instanceOf: 클래스 변환이 가능한지 불가능한지 알려주는 연산자
-조건문과 같이 활용됨. 

인터페이스
 - 추상 메소드와 클래스 상수로만 이루어진 것
 - 기능들을 표준화, 기능 명세

추상 메소드
 - 메소드 구현부가 없는 메소드
 - 기능을 사용하려면 메소드 오버라이딩을 통해 구형을 한 후, 호출해야함.

구현 클래스 : 인터페이스를 구현한 클래스
 -인터페이스에 있는 메소드들을 반드시 오버라이딩해야한다.
 -구현 클래스는 여러 인터페이스를 구현할 수 있다.

class A implements InterfaceA, InterfaceB{}
 동시에 여러 인터페이스를 구현할 수 있다.

-상속과 구현은 같이 할 수 있다. 

class Child extends Parent implements InterfaceA{}


String 클래스
 -indexOf(), equals(), length(), subString(), split()

Object 클래스 => 모든 객체들의 조상
-equals(), toString() 오버라이딩을 해서 사용한다. 

Wrapper 클래스 :  기본 자료형의 클래스화
int -> Integer
boolean -> Boolean
char -> Charater
double -> Double

기본 자료형을 클래스화, 객체화 할 필요가 있을 때 사용. 


프로그램 오류

컴파일 에러, 런타임에러, 시스템에러

소스 수정으로 해결가능한 에러를 예외(Exception)라고 하는데 
이러한 예외상황 구문을 처리하는 방법인 예외처리를 통해 해결

RuntimeException 클래스
unchecked Exception으로 주로 프로그래머의 부주의로 인한 오류인 경우가 많기 때문에 
예외 처리보다 코드를 수정해야하는 경우가 많음


예외처리방법
	1. Exception이 발생한 곳에서 직접 처리
		try~catch문을 이용하여 예외처리
		try: exception이 발생할 수 있는 영역을 try{}로 감싸줌.
		
		catch: try 구문에서 발생하는 해당 예외에 대한 처리를 기술해주는 영역.
		여러개으 exception 처리가 가능하나 exception간의 상속관계를 고려해야함.	


		finally : 예외처리 결과로 최종적으로 항상 실행되는 코드를 기술하는 영역


컬랙션
	자바에서 제공하는 자료구조를 담당하는 프레임워크(정형화된 틀)

	추가, 삭제, 정렬 등의 기능처리가 간단하게 해결되어 자료구조적 알고리즘을 구현할 필요 없음.



배열의 문제점
1. 한번 크기를 정하면 변경불가

2. 배열 중간 위치 데이터의 추가, 삭제가 불편
	한 값을 지우거나 추가하려면 작업하고 땡기는 작업, 밀어내는 작업 추가로 수행해야함.


컬렉션의 장점
1. 크기의 제약 x
2. 추가 삭제 정렬 등의 기능이 내장되어 있음
3. 여러타임의 데이터 저장 가능. 
	단 클래스의 객체만 가능하기에 기본자료형의 경우 wrapper클래스를 사용해야함.


컬랙션, 맵
컬랙션에 리스트와 셋이 포함



컬랙션 
ㄴ리스트	: 순서를 유지, 중복 저장 가능
ㄴ셋 : 순서 유지 X, 중복 저장 X

맵


리스트 : 자료들을 순차적으로 나열한 자료구조. 인덱스로 관리, 중복해서 객체 저장 가능(중복은 equals로 판별) (때문에 오버라이딩 필요)


ArrayLIst
list의 후손. 초기저장 용량은 10, 따로 초기용량 지정도 가능
	저장용량 초과시 자동으로 늘어나며 고정도 가능.
	동기화를 제공하지 않음. 

Vector . ArrayLIst와 같으나 동기화를 제공함
	List객체 중에서 성능 제일 구림

LinkedLIst : 앞뒤로 연결된 체인구조. 객체 삭제와 삽입이 빈번하게 일어나는 곳에서 사용되면 좋음.








셋 : 중복 저장 안됨. 저장 순서 유지 안됨. null도 중복 저장 안되어서 1개의 null만 저장. 












