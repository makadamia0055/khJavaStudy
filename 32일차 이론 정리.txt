12월 6일 이론 정리

전체 정리

1. 변수 
	- 데이터를 저장하기 위한 공간;
	- 값이 바뀔 수 있다. 
	
	- 변수 선언 방법
	데이터형 변수명 = 초기값
	-기본타입(기본 자료형)
	정수 : byte, short, int , long
	문자 : char(2byte)
	논리 : boolean (1byte)
	실수 : float, double - 소수점 자리 : 정확도 , 표현범위 차이
	float 형 뒤에는 f를, long형 뒤에는 L을 붙인다.

- 자료형 변환
	-변수/상수의 자료형을 일시적으로 변환시키는 것
	- 자동(묵시적)
	정수=> 실수
	작은 바이트-> 큰 바이트

	- 강제(명시적)
	자동으로 안되는 경우
	상황에 따라서 자동으로 되는 상황이지만 필요에 의해 강제로 하는 경우도 있음.
	=> / 연산할 때 

- 변수명 작성 규칙
	- 숫자가 첫글자가 될 수 없고
	-특수문자는 _, $만 가능
	-변수명 중복 선언 불가
		=> 필드와 지역변수는 중복 될 수 있다.
			-> 필드는 this.필드명으로 지역변수와 구분하여 접근할 수 있기 때문에
		-> 같은 범위에서 동일한 이름을 가진 지역 변수를 선언할 수 없음. 

	-대소문자 구별

 - 변수명 작성 관례
	-카멜 표기법 : 변수명을 소문자로 작성하고, 여러 단어로 된 변수명인 경우 두번째 단어부터 단어의 첫 글자만 대문자로
	-클래스/ 인터페이스/ 열거형의 이름은 소문자로 작성하되, 첫번째 단어부터 단어의 첫글자만 대문자로
	-변수명은 의미있게
	  구글 번역이나, 네이버 사전을 통해


	- 상수
		- 리터럴 상수
		-ex) 1, '1', "1", true 등의 실제 값들
		- 리터럴 상수를 저장하는 공간이 따로 있어서 상수 풀(Constant pool) 리터럴 상수가 언급되면 해당 풀에 
		- 문자열인 경우 같은 리터럴 문자열을 저장하는 문자열 객체들은 String Constant pool에 저장되고 
		- 사용될 때 같은 주소를 공유

		- 상수 변수(상수 필드)
		-ex) 변수 앞에 final 키워드가 붙어서 상수로 만듦. 값을 바꿀 수 없게 만든 것.

		-지역 변수인 상수는 선언과 동시에 초기화를 반드시 해야한다.(stack에 저장되는거 말하는듯)

		-필드인 상수는 생성자에서 초기화 할 수 있음.


변수 종류
	-지역 변수 : 메소드 안에서 선언된 변수, 메소드를 빠져나가면 사라짐.
	-필드 : 클래스의 멤버 변수
	-매개변수 : 메소드를 실행할 때 필요한 변수들. 메소드를 빠져나가면 사라짐.
	-참조변수 : 객체, 열거형 등을 통해 만들어진 인스턴스를 저장하는 변수
		  기본 자료형이 아닌 변수들
	-클래스 변수 : static 이 붙은 필드들. 동일한 클래스의 인스턴스들이 공유하는 변수. Data 영역에 저장됨. 클래스명으로 호출
	-인스턴스(객체) 변수 : static이 안붙은 필드들, 객체마다 필드가 존재, 인스턴스 명으로 호출

매개변수와 인자
	-매개변수는 메소드 선언부에 있는 변수
	-인자는 메소드를 호출할 때 넘겨주는 값(변수/상수)
int sum(int num1, int num2){ <-매개변수
	return num1+num2;
}

sum(1,2) <-인자

String은 임뮤터블
	String str = "123";
	str = "1234";
	문자열 "123"에 "4"를 추가하거나 문자열 "123"을 "1234"로 바꾸는 것이 아니라
	새로운 문자열 "1234"를 만들어 참조변수 str에 대입함. String은 수정이 불가능한 객체이므로.
	이러한 객체로 기본데이터형의 래퍼 클래스들이 있다.




연산자
-대입 : =, 오른쪽 값을 왼쪽에 저장
 => ==와 혼동하지 말자.
-산술 : + - * / %
	정수 연산자 정수 = 정수
	특히 나누기 조심
	/와 %는 제수로 0을 가질 수 없다. ArithmeticException 발생

비교  <>: 크기 비교
	참/거짓 => 조건식
-논리 : && || !
	-&& : ~이고, 하고, 둘다 참이면 참 and
	-|| : ~이거나 둘 중 하나만 참이면 참, 둘다 거짓이면 거짓 ot	
	-! : 반대
	-조건식

-증감연산자 ++ --
	-전위 : 증가하고 동작
	-후위 : 동작하고 증가

- 부호연산자 : - 부호 바꾸는거

-비트연산자 : 생략

-조건선택 연산자 : 꼭 알 필요 없지만 잘 사용하면 코드가 깔끔해진다. 
	-> 조건식으로 대체가능하나 쓰면 좀 더 코드 간결하게 쓰기 가능
	형식 : 조건식 ? 참: 거짓

조건식
	- 조건에 따라(상황에 따라) 결과가 달라질 때 조건식을 사용
	- ~이면 ...한다
	if문, switch문
if문
-모든 조건식은 if문으로 표현 가능
-~이면 ...한다
	~: 조건식 , ...: 실행문
기본 문법
if(조건식 1){
	실행문1;
}else if(조건식 2){
실행문2;
}else{
실행문3;
}

	-if문 : 필수 . ~이면
	-else if문 0개 이상 . 위의 조건이 아니라 ~가 참이면
	-else문 0개 또는 1개 . 위의 조건이 참이 아닐 때

switch문
	-if문으로 처리할 수 있지만 특정 상황이면 switch를 쓰는게 코드가 더 깔끔한 경우가 있다.
	-변수에 저장된 값에 따라 다르게 실행되는 경우/특정 연산 결과에 따라 결과가 제한적이며 다르게 실행되는 경우

switch(변수명/식){
case 값1: 실행문1;
	break;
case 값 2: 실행문2; break;
default: 실행문;
}
 - case 값에는 문자, 정수, 문자열만 가능
 -break는 생략 가능
 - default도 생략 가능

반복문
	-반복적인 작업을 규칙적으로 할 때
	=> 반복 횟수, 규칙성
	=> 반복 횟수 -> 초기화 + 조건식 + 증감식
	=> 규칙성 => 실행문
for(초기화;조건식;증감식){
	실행문;
}

//초기화
while(조건식){
	실행문;
	//증감식;
}	

do{
실행문;
}while(조건식);

향상된 for문=> 전체 탐색
for(데이터형 변수명 : 배열 또는 컬랙션){
실행문;
}

배열 
 - 같은 데이터형의 변수들을 모아 저장한 객체; +(같은 의미)
 - 배열은 크기가 고정(<->컬렉션은 늘어남)
 - 배열은 제공하는 메소드가 없음. (<->컬렉션은 있음)
 - 배열은 기본자료형도 생성가능하지만 컬렉션은 레퍼클래스를 이용해야함.
 - 배열은 참조 변수. 주소를 저장. 
 => 할당된 배열이 있는 0번지의 주소를 저장
	- 배열 선언 방법
	데이터형[] 배열명1, 배열명 2; // 둘다 배열
	데이터형 배열명3[], 배열명 4 ; // 배열명 3만 배열

배열 할당
배열명 = new 타입[크기];
-배열은 번지를 통해 접근 가능
-배열은 0번지부터 크기-1번지까지
-배열 이용시 ArrayIndexOutOfBoundsException조심
-배열의 크기는 length를 이용하여 알 수 있다.
-배열은 할당하면 각 번지에 있는 값들이 기본 값으로 초기화가 된다. 
	-정수 0, 실수 : 0.0, 참조변수 : null, 문자 '\u0000'
-배열을 왜 사용하나?
	=> 반복문을 이용하여 효율적으로 코딩할 수 있다.

메소드 
	-하나의 기능을 모아놓은 코드
	- 입력정보 : 매개변수, 출력정보: return타입
	- 매개변수 : 메소드를 실행하기 위해 꼭 필요한/요청할 정보

메소드 오버로딩 
	- 동일한 메소드 명으로 여러개의 메소드를 만드는 것
	-조건 : 메소드명 동일
	- 매개변수의 갯수가 다르거나, 타입이 다르거나, 순서가 달라야한다.
	-리턴타입/접근제한자는 상관 없음.

접근제한자
-private : 해당 메소드 내부에서만 사용 가능
-default : 해당 메소드 + 같은 패키지
-protected : 해당 메소드 + 같은 패키지 + 자식 클래스
-public : 전부


클래스
 - 필드 : 클래스를 나타내는 정보들. 
	학생 클래스는 이름, 학년, 반, 번호 등의 정보들을 가지고 있다.
 - 생성자 : 필드를 초기화 하는 곳. return 타입이 없다. (void 아님)
	생성자 이름은 클래스 명과 동일
 - 메소드 : 클래스에서 실행하는 기능들 
	-리모컨 클래스는 전원을 켜기/끄기가 있어야 한다.

클래스의 특성
	- 캡슐화, 상속, 다형성
	캡슐화 : 클래스의 내부에서 정보를 처리하고 외부로 배출하는데 그 과정은 밖에 드러내지 않는다. 
	상속 : 자식에게 필드 메소드를 물려주는 것
	-> 코드의 재사용성, 다형성의 구현
	다형성 : 부모클래스의 객체로 다양한 자식 클래스의 객체를 관리할 수 있는 것
	- 객체의 다형성 : 지역변수나 필드를 만들때 부모객체의 변수를 선언하면 자식클래스의 인스턴스를 대입 가능;
	List<Board> boardList = newArrayList<board>();
	List<Board> boardList = newLinkedList<board>();
	- 매개변수의 다형성 : 메소드의 매개변수로 여러 데이터 형을 받을 수 있음.
	

- 객체 생성
클래스 명 객체명 = new 생성자(매개변수);

-객체에서 메소드 호출
객체명.메소드명(매개변수들);

객체에서 특정 정보 호출
Product p = new Product("신발", "슬리퍼", 1000, 2000);

String type = p.getType();
If(type.equals("신발")){

}

- 메소드 호출
	-클래스 메소드 : 클래스명.메소드명();

	-인스턴스 메소드 : 인스턴스명.메소드명();

생성자 오버로딩: 메소드 오버로딩과 같음

상속
- 코드의 경제성보다는 사실상 다형성 때문에 사용하는 것
- 부모 클래스의 필드/메소드를 물려 받는 것
- 접근 제한자에 따라 접근하지 못하는 필드/ 메소드가 있을 수 있음
- extends를 사용해서 상속
class 자식 클래스명 extends 부모 클래스명{

}

-자식 클래스는 부모클래스가 1개 
=> 클래스 상속은 단일 상속. 부모가 2명 이상일 수 없음. (인터페이스는 다중상속 가능)

메소드 오버라이딩
-부모클래스의 메소드를 자식 클래스에서 재정의하는 것
- 메소드 명이 동일
- 매개변수 갯수와 타입이 동일
- 접근제한자는 부모클래스 메소드의 접근제한자보다 같거나 넓어야 한다. 
- 리턴 타입도 동일
	// 부모로 업캐스팅해도 자바는 모든 함수가 가상함수라 자식 클래스 오버라이딩한거 호출됨.

- 예외 던지기도 조상 예외로 하는 건 괜찮지만 좁아지면 안됨. 
	-> 부모 클래스의 메소드가 RuntimeException이 발생하는데, 
	자식이 오버라이딩할 때 ArithmeticException으로 좁힐 수 없다.

this와 super
	-this는 클래스 자신을 참조하는 변수.
	-super는 부모클래스의 객체를 참조하는 변수
	-this() 클래스 자신의 다른 생성자를 호출
	-super()는 부모클래스의 생성자를 호출
	

메소드와 this
	- 클래스의 매소드에서 this를 사용하는 경우 
	 - 항상 사용이 가능하나 
	- 주로 매개변수 명과 필드 명이 같은 경우 구분을 위해 this를 사용


클래스의 형변환
- 자동(업캐스팅)
부모 클래스 변수명 = new 자식클래스생성자();
	-부모 클래스의 참조변수에 자식클래스를 대입하면 '자식클래스에만 구현된 부분을 잠그고' 부모클래스로 사용가능

- 강제
	업캐스팅한 자식 클래스의 메소드를 사용하고 싶을때
	=> ((자식클래스명)참조변수명).메소드()	
	혹은 부모클래스 참조변수a = new 자식클래스생성자();
	       자식 클래스 잠조변수b = (자식클래스)참조변수a;

	이게 아닌 경우는 ClassCastingException이 발생

기본 API
-Wrapper 클래스
	기본 자료형을 클래스로 만든 것
byte=>Byte
short->Short	
int => Integer
long-> Long
char => Charater	
float -> Float
double -> Double

왜 쓰는가? 제네릭 클래스는 <>안에 클래스 명이 필요함
	-> 기본 자료형을 쓸 수 없음.
	-> 기본 자료형을 대체할 수 있는 래퍼 클래스 이용
	
래퍼 자료형마다 String에서 추출하는 parse가 있음. 
반대로 String으로 만드는 것은 valueOf() 가 있는데 잘 안씀. 

 - 박싱 : 기본 자료형을 래퍼클래스의 객체로 만드는 것
 - 언박싱 : 래퍼클래스의 객체를 기본 자료형으로 만드는 것
 - 래퍼 클래스 객체 사용시 null체크 주의.


-String
	-문자열 클래스
	-String 객체는 임뮤터블 (String 객체에 값을 수정하면 새로운 문자열이 만들어져 교체되는 것)
	-메소드
	length() : 문자열의 길이 리턴
	substring(int start, int end) : start번지부터 end-1번지까지 부분 문자열 리턴, (문자열 슬라이싱)
	charAt(int index) index번지에 있는 '문자'를 가져옴
	split(구분자) : 구분자를 기준으로 문자열들을 추출하여, 문자열 배열을 리턴함.
	indexOf("문자열") : 대상 문자열이 있으면 시작번지를, 없으면 -1을 리턴;
	toUpperCase(); 문자열을 모두 대문자로;
	toLowerCase(); 문자열을 모두 소문자로;
	
-Date
	- 날짜 정보를 관리하는 클래스
	- Date-> 문자열로

	Date date = new Date();
	SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd);
	String dateStr = f.format(date);

	-문자열->Date로

	String str =....
	Date date = format.parse(str);

- Math
	-min(int num1, int num2); 최소값 리턴;
	-max(int num1, int num2); 최대값 리턴;
	-abs(int num): 절대값
	-round(double num) : 반올림(소수점 첫번째 자리);
	-floor(double num) : 버림(소수점 첫번째 자리);
	ceil(double num) : 올림(소수점 첫번째자리);
	pow(a,b) : a의 b제곱;
	sqrt(a) : 루트 a; 
	

-StringTokenizer : 구분자를 기준으로 문자열들을 가져와서 확인해주는 클래스 
	String 클래스의 split과 유사
	countTokens() : 현재 토큰의 개수
	hasMoreTokens() : 토큰이 더 있는지 참/ 거짓으로 알려줌
	nextToken() : 다음 토큰

-Object
	- 모든 클래스의 최상위 조상 클래스 => 모든 클래스는 Object 클래스에 있는 메소드를 가지고 있다.
	- 오버라이드를 통해 재정의 할 수 있다. 
	
	equals() : Object클래스의 equals는 주소가 같은 객체인 경우에만 true
		객체의 필드들이 같더라도 같은 주소의 객체가 아니면 false
		오버라이딩을 이용하여 필드가 같으면 같은 객체로 판별하도록 해야함.
	toString()	 : 패키지 명과 클래스 명 + @16진수 주소가 나옴
		-객체를 통해 간단히 필드들을 확인, 출력할 때 오버라이딩해서 사용
	
	hashCode() : 잘 안써서 생략

추상메소드 
	-메소드 구현부가 없는 메소드 
	-오버라이딩을 통한 구현이 필요한 메소드

추상클래스 
	- 추상메소드가 0개 이상 있는 메소드
	- 키워드로 abstract, 추상메소드에는 반드시 abstract를 추가
	- 추상 클래스를 상속 받은 자식 클래스를 생성한 후, 추상메소드들을 오버라이딩하고 자식 클래스의 참조값을 참조변수로 받을 수 있다.
	

인터페이스
	-추상메소드와 클래스상수(final static) 필드로 구성된 
	-메소드에 abstract와 public를 생략해도 자동 추가
	-구현 클래스를 생성한 후, 추상 메소드들을 오버라이딩하고 생성된 구현클래스의 참조값을 참조변수로 받을 수 있다.


예외처리
-직접 처리
	try~catch

try{
예외가 발생할 수 있는 코드

}catch(예외클래스 1 e){
}catch(예외클래스 2 e){
}finally{
}

-예외 클래스 1과 예외 클래스 2의 관계는 무관하거나, 자식 클래스가 먼저 나와야한다. 
	조상 클래스가 먼저 나오면 해당 오류를 다 처리해버리고 뒤의 catch문은 처리된 것으로 간주하기 때문.
	예외 클래스 2에 예외 클래스 1의 자손 클래스가 오면 에러가 발생;


예외 던지기
	throw	
	-> 보통 조건문과 같이 사용해서 throw함
	throw new 예외클래스명(예외메세지);

	throws
	->throw를 이용하는 경우 메소드에 예외가 발생할 수 있다는 것을 표시할 때 사용
	-> RuntimeException이거나 그 자손 클래스이면 생략가능, 아니면 생략 불가

-흔하게 나오는 예외 클래스 종류
	-ArithmeticException : 0으로 나눌때 발생
	-ArrayIndexOutOfBoundsException : 배열의 범위를 벗어날 때 발생
	-NegativeArraySizeException : 배열의 크기를 음수로 했을 때 발생
	-NullPointerException : null인 객체의 필드나 메소드에 접근하려고 했을 때
	-ClassCastException : 클래스 변환에 실패했을 때 
	-FileNotFoundException : 파일을 찾을 수 없을 때

컬렉션 프레임워크
	-데이터를 효율적으로 관리하기 위한 것
	- 컬렉션
	공통
	 -add(E e) 요소 추가하고 true/false 리턴
	 -remove(E e) 요소 제거하고 true/false 리턴
	 -size() : 크기
	 - isEmpty() : 비었으면 true 아니면 false

	Iterator를 이용하여 하나씩 반복하여 요소를 꺼낼 수 있다. 외부반복자.
	리스트와 셋은 향상된 for문을 이용하여 접근할 수 있다(map은 안됨)
	
	- 리스트
	 get(int index) : index 번지 요소 리턴
	 set(int index, Obj o) : index번지 요소를 o로 수정
	 remove(int index) : index 번지 요소를 제거하고 성공하면 제거한 객체 리턴
	
	- 셋 : 순서가 없음. 중복 불가

	- 맵 : key와 value로 이루어짐
	-key는 중복 불가
	-value는 중복 가능
	put(K key, V value) : key와 value를 map에 추가
	get(K key) : key와 일치하는 value를 반환
	set(K key, V value) : key와 일치하는 객체에 value로 수정
	keySet(); key값들을 set으로 반환
	entrySet() : key와 value값들을 key와 value로 구성된 Entry 클래스 객체로 만들고 set에 저장하여 반환

	반복문 활용(전체 탐색)
	1. keySet()을 이용하여 key값들을 이용하여 get로 가져온다. Iterator 이용
	2. entrySet()을 이용하여 Entry 클래스 객체 가져오고  Entry클래스 객체의 key와 value 값을 활용 Iterator


파일 입출력



네트워크


시험범위 : 메소드 오버로딩부터 클래스부터 다 나오는데 조금씩 골고루. 